import pandas as pd
import matplotlib.pyplot as plt

# ===============================
# 读取数据 & 参数设置
# ===============================
df = pd.read_csv("data.csv")
df = df[df["comprehensive_score"].notna()].copy()
df["date"] = pd.to_datetime(df["date"])
df = df.sort_values(["date", "ticker_id"])

# df = df[(df["date"] >= pd.Timestamp("2025-10-01")) & (df["date"] <= pd.Timestamp("2025-11-14"))]


# ===============================
# 工具函数
# ===============================
def filter_stocks_on_date(current_df: pd.DataFrame) -> pd.DataFrame:
    """
    当日选股条件：
    - 3个综合分数在一定区间
    - 当日综合分数 > 5日综合分数
    - 按综合分数从高到低排序
    """


    # filtered = current_df[
    #     (current_df['comprehensive_score'] >= 10) &
    #     (current_df['comprehensive_score'] <= 25) &
    #     (current_df['comprehensive_score_3_days'] >= 5) &
    #     (current_df['comprehensive_score_3_days'] <= 15) &
    #     (current_df['comprehensive_score_5_days'] >= 0) &
    #     (current_df['comprehensive_score_5_days'] <= 10)&
    #     (current_df['market_avg_comprehensive_10_days'] > 0)
    # ]

    # 15533
    filtered = current_df[
        # ① 综合得分进入稳定偏多区间，但不追高
        (current_df['comprehensive_score'] >= 25) &
        (current_df['comprehensive_score'] <= 45) &

        # ② 动能必须顺势增强：3日 > 5日 > 10日
        (current_df['comprehensive_score_3_days'] > current_df['comprehensive_score_5_days']) &
        (current_df['comprehensive_score_5_days'] > current_df['comprehensive_score_10_days']) &

        # ③ 不要高潮（避免到达 60–100 的高危区域）
        (current_df['comprehensive_score_20_days'] <= 55) &

        # ④ SMA 趋势明显加强（>15 为强趋势区）
        (current_df['sma_score'] > 15) &

        # ⑤ 价格稳站在 VWAP 上（趋势确认）
        (current_df['vwap_score'] > 5) &

        # ⑥ 资金流向正面（拒绝资金流出）
        (current_df['mfi_score'] >= 0) 

        # ⑦ 大盘行情偏多：避免系统性回调日
        & (current_df['market_avg_comprehensive_10_days'] > 5) 
    ]

    # 14866
    # filtered = current_df[
    #     # ① 个股相对大盘强势
    #     (current_df['comprehensive_score'] - current_df['market_avg_comprehensive_10_days'] >= 10) &
    #     (current_df['comprehensive_score'] - current_df['market_avg_comprehensive_10_days'] <= 40) &

    #     # ② 趋势增强（3日 > 5日 > 10日）
    #     (current_df['comprehensive_score_3_days'] > current_df['comprehensive_score_5_days']) &
    #     (current_df['comprehensive_score_5_days'] > current_df['comprehensive_score_10_days']) &

    #     # ③ 不追高（避免大涨后回落）
    #     (current_df['comprehensive_score_20_days'] <= 55) &

    #     # ④ 短期趋势明显偏强
    #     (current_df['sma_score'] > 15) &

    #     # ⑤ 价格向上脱离均衡成本
    #     (current_df['vwap_score'] > 5) &

    #     # ⑥ 资金流向正面
    #     (current_df['mfi_score'] >= 0) &

    #     # ⑦ 排除系统性崩盘日（弱化大盘影响）
    #     (current_df['market_avg_comprehensive_10_days'] > -10)
    # ]

    
    filtered = filtered.sort_values("comprehensive_score", ascending=True)
    return filtered


def total_portfolio_value(cash: float, positions: dict) -> float:
    """
    总资产 = 现金 + 所有持仓市值
    """
    return cash + sum(p["shares"] * p["last_price"] for p in positions.values())


def log_trade(trade_history: dict, date, ticker, action, price, shares, cash, positions: dict):
    """
    记录每一笔交易，并记录当日总资产（现金+持仓）
    """
    trade_history['date'].append(date)
    trade_history['ticker_id'].append(ticker)
    trade_history['action'].append(action)
    trade_history['price'].append(price)
    trade_history['shares'].append(shares)
    trade_history['cash_balance'].append(cash)
    trade_history['portfolio_value'].append(total_portfolio_value(cash, positions))


def print_positions(trade_history: dict):
    """
    根据 trade_history 画：
    - 总资产曲线
    - 回撤曲线
    并打印最大回撤
    """
    trade_df = pd.DataFrame(trade_history)
    if trade_df.empty:
        print("No trades were made.")
        return

    trade_df["date"] = pd.to_datetime(trade_df["date"])
    trade_df = trade_df.sort_values("date")

    # 每天最后一笔交易的 portfolio_value 作为当日净值
    equity_series = trade_df.groupby("date")["portfolio_value"].last()

    running_max = equity_series.cummax()
    drawdown = equity_series / running_max - 1.0
    max_drawdown = drawdown.min()
    print("Max Drawdown:", max_drawdown)

    # 总资产曲线
    plt.figure(figsize=(12, 5))
    plt.plot(equity_series.index, equity_series.values)
    plt.title("Equity Curve (Total Portfolio Value Over Time)")
    plt.xlabel("Date")
    plt.ylabel("Portfolio Value")
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    # 回撤曲线
    plt.figure(figsize=(12, 4))
    plt.plot(drawdown.index, drawdown.values)
    plt.title("Drawdown Curve")
    plt.xlabel("Date")
    plt.ylabel("Drawdown (relative)")
    plt.grid(True)
    plt.tight_layout()
    plt.show()


# ===============================
# 核心回测函数（含止盈 + 止损 + 最长持有）
# ===============================
def run_backtest(
    df: pd.DataFrame,
    max_hold_days: int,
    take_profit: float ,
    max_positions: int,
    initial_cash: float,
    stop_loss: float | None  # 例如 0.05 = 跌 5% 止损；0.10 = 跌 10%；None = 不止损
):
    # 初始化资金、持仓、交易记录
    cash = initial_cash
    positions: dict = {}

    trade_history = {
        'date': [],
        'ticker_id': [],
        'action': [],          # BUY / SELL_TP / SELL_MAX_DAYS / SELL_SL
        'price': [],
        'shares': [],
        'cash_balance': [],
        'portfolio_value': []
    }

    all_dates = sorted(df["date"].unique())

    for current_date in all_dates:
        # 当天所有数据
        current_df = df[df["date"] == current_date]

        # 1) 更新持仓当日价格（last_price）
        for ticker, pos in positions.items():
            row = current_df[current_df["ticker_id"] == ticker]
            if not row.empty:
                last_close = float(row["close"].iloc[0])
                pos["last_price"] = last_close
            # 如果当天没有该股票的报价，就维持昨天的 last_price 不变

        # 2) 更新持仓天数 + 卖出逻辑（止盈 / 止损 / 最长持有）
        tickers_to_close = []

        for ticker, pos in positions.items():
            pos["holding_days"] += 1

            current_price = pos["last_price"]
            buy_price = pos["buy_price"]

            sell_reason = None

            # 止盈：涨到 take_profit 比例
            if current_price >= buy_price * (1 + take_profit):
                sell_reason = "TP"

            # 止损：跌到 stop_loss 比例（如果设置了）
            elif (stop_loss is not None) and (current_price <= buy_price * (1 - stop_loss)):
                sell_reason = "SL"

            # 最长持有天数
            elif pos["holding_days"] >= max_hold_days:
                sell_reason = "MAX_DAYS"

            if sell_reason is not None:
                tickers_to_close.append((ticker, sell_reason))

        # 真正执行卖出
        for ticker, reason in tickers_to_close:
            pos = positions[ticker]
            sell_price = pos["last_price"]
            shares = pos["shares"]

            proceeds = sell_price * shares
            cash += proceeds

            # 先从持仓里删除，再记录交易，这样 portfolio_value 不会把已经卖掉的仓位算进去
            del positions[ticker]

            log_trade(
                trade_history=trade_history,
                date=current_date,
                ticker=ticker,
                action=f"SELL_{reason}",
                price=sell_price,
                shares=shares,
                cash=cash,
                positions=positions
            )

        # 3) 空仓位数量
        available_slots = max_positions - len(positions)
        if available_slots <= 0:
            continue

        # 4) 筛选当日可买股票
        candidates = filter_stocks_on_date(current_df)

        # 不重复买已经持有的票
        if positions:
            held_tickers = set(positions.keys())
            candidates = candidates[~candidates["ticker_id"].isin(held_tickers)]

        if candidates.empty:
            continue

        # 只取前 available_slots 只
        candidates = candidates.head(available_slots)

        if cash <= 0:
            continue

        # 5) 均分现金买入
        n_to_buy = len(candidates)
        cash_per_stock = cash / n_to_buy

        for _, row in candidates.iterrows():
            price = float(row["close"])
            ticker = row["ticker_id"]

            if price <= 0:
                continue

            shares = cash_per_stock / price
            cost = shares * price

            if cost > cash:
                cost = cash
                shares = cost / price

            if shares <= 0:
                continue

            cash -= cost

            positions[ticker] = {
                "buy_price": price,
                "shares": shares,
                "holding_days": 0,
                "last_price": price
            }

            log_trade(
                trade_history=trade_history,
                date=current_date,
                ticker=ticker,
                action="BUY",
                price=price,
                shares=shares,
                cash=cash,
                positions=positions
            )

    # 回测结束，计算最终总资产
    final_value = total_portfolio_value(cash, positions)
    return cash, final_value, positions, trade_history


# ===============================
# 实际调用
# ===============================


cash, final_value, positions, trade_history = run_backtest(
    df,
    max_hold_days = 10,
    take_profit = 0.04,
    max_positions = 5,
    initial_cash = 10000,
    stop_loss = 0.1  #这里改成 0.10 就是 10% 止损；None 表示不止损
)

print("Final cash:", cash)
print("Final portfolio value:", final_value)

trade_df = pd.DataFrame(trade_history)
trade_df.to_csv("results.csv", index=False)

print_positions(trade_history)
